<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Decentralized Sharing</title>
        <!-- <link rel="stylesheet" href="./css/main.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"></script> -->
    </head>
    <body>
        <!-- <div id="start">
            <button id="stream-button">Start Streaming</button>
        </div><br><br> -->
        <div id="select-file-dialog">
            <div id="dialog-content">
                <div id="select-file">
                    <div id="label">Select a file:</div>
                    <input type="file" id="select-file-input">
                </div>
                <br>
                <br>
                <div id="dialog-footer">
                    <button id="send-button" disabled>Send</button>
                    <!-- <button id="cancel-button" class="cancel-button">Cancel</button> -->
                </div>
            </div>
        </div>
        <div id="receiver">
            <h3>Received File Text:</h3>
            <br>
            <textarea id="recText" rows="50" cols="100"></textarea>
        </div>
    </body>

</html>
<script>
  (function () {
  "use strict";

  const MESSAGE_TYPE = {
    SDP: 'SDP',
    CANDIDATE: 'CANDIDATE',
  }

  const MAXIMUM_MESSAGE_SIZE = 65535;
  const END_OF_FILE_MESSAGE = 'EOF';
  let DATA_PERCENTAGE = 'FULL'
//   let code;
  let peerConnection;
  let signaling;
  const senders = [];
  let userMediaStream;
  let displayMediaStream;
  let file;

  const startChat = async () => {
    try {
    //   userMediaStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
      //showChatRoom();

      signaling = new WebSocket('ws://127.0.0.1:1337');
      peerConnection = createPeerConnection();
      // manually triggering this event
      peerConnection.onnegotiationneeded();
      addMessageHandler();
      document.getElementById('select-file-dialog').style.display = 'block';
      
    } catch (err) {
      console.error(err);
    }
  };

  const createPeerConnection = () => {
    const pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.m.test.com:19000' }],
    });

    // triggered by addTrack event for mediastreams.
    pc.onnegotiationneeded = async () => {
      await createAndSendOffer();
    };

    pc.onicecandidate = (iceEvent) => {
      if (iceEvent && iceEvent.candidate) {
        sendMessage({
          message_type: MESSAGE_TYPE.CANDIDATE,
          content: iceEvent.candidate,
        });
      }
    };

    pc.ondatachannel = (event) => {
      const { channel } = event;
      channel.binaryType = 'arraybuffer';
      console.log("Data Received.")
     
      const receivedBuffers = [];
      channel.onmessage = async (event) => {
        const { data } = event;
        try {
          if (data == "HALF" || data =="FULL") {
            DATA_PERCENTAGE = data
          }

          else {
          if (data !== END_OF_FILE_MESSAGE) {
            let textContent = String.fromCharCode.apply(null, new Uint8Array(data))
            document.getElementById('recText').value += textContent;
          } else {
            channel.close();
          }
        }
        } 
        catch (err) {
          console.log('File transfer failed');
        }
      };
    };

    return pc;
  };

  const addMessageHandler = () => {
    signaling.onmessage = async (message) => {
      const data = JSON.parse(message.data);
      if (!data) {
        return;
      }

      const { message_type, content } = data;
      try {
        if (message_type === MESSAGE_TYPE.CANDIDATE && content) {
          await peerConnection.addIceCandidate(content);
        } else if (message_type === MESSAGE_TYPE.SDP) {
          if (content.type === 'offer') {
            await peerConnection.setRemoteDescription(content);
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            sendMessage({
              message_type: MESSAGE_TYPE.SDP,
              content: answer,
            });
          } else if (content.type === 'answer') {
            await peerConnection.setRemoteDescription(content);
          } else {
            console.log('Unsupported SDP type.');
          }
        }
      } catch (err) {
        console.error(err);
      }
    }
  }

  const sendMessage = (message) => {
      signaling.send(JSON.stringify({
        ...message,
      }));
    
  }

  const createAndSendOffer = async () => {
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);

    sendMessage({
      message_type: MESSAGE_TYPE.SDP,
      content: offer,
    });
  }

  const shareFile = (config) => {
    if (file) {
      const channelLabel = file.name;
      const channel = peerConnection.createDataChannel(channelLabel);
      channel.binaryType = 'arraybuffer';

      channel.onopen = async () => {
        const arrayBuffer = await file.arrayBuffer();
        let textContent = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer))
        let textArray = textContent.split("\n");
        // for (let i = 0; i < arrayBuffer.byteLength; i += MAXIMUM_MESSAGE_SIZE) {
        //   channel.send(arrayBuffer.slice(i, i + MAXIMUM_MESSAGE_SIZE));
        // }

        let len;
        if (DATA_PERCENTAGE == "HALF") {
            len = textArray.length / 2
        } else {
            len = textArray.length
        }

         
        for (let i=0; i<len; i++) {
            let str = textArray[i]
            var buf = new ArrayBuffer(str.length);
            var bufView = new Uint8Array(buf);
            for (var j = 0, strLen = str.length; j < strLen; j++) {
                bufView[j] = str.charCodeAt(j);
            }
            channel.send(buf);
        }
        channel.send(END_OF_FILE_MESSAGE);
      };

      channel.onclose = () => {
        //closeDialog();
      };
    } 
    // else if (config == 'request') {
    //   const channelLabel = config;
    //   const channel = peerConnection.createDataChannel(channelLabel);
    //   channel.binaryType = 'arraybuffer';

    //   channel.onopen = async () => {
    //     channel.send(document.getElementById('preference').value);
    //   };

    //   channel.onclose = () => {
    //     //closeDialog();
    //   };
    // }
  };


  const downloadFile = (blob, fileName) => {
    const a = document.createElement('a');
    const url = window.URL.createObjectURL(blob);
    a.href = url;
    a.download = fileName;
    a.click();
    window.URL.revokeObjectURL(url);
    a.remove()
  };


  document.getElementById('select-file-input').addEventListener('change', (event) => {
    file = event.target.files[0];
    document.getElementById('send-button').disabled = !file;
  });

  document.getElementById('send-button').addEventListener('click', () => {
    shareFile('data');
  });

  startChat();

})();
</script>
