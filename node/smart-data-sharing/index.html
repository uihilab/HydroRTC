<style>
    button, input, select {
        font-family: Myriad, Arial, Verdana;
        font-weight: normal;
        border-top-left-radius: 3px;
        border-top-right-radius: 3px;
        border-bottom-right-radius: 3px;
        border-bottom-left-radius: 3px;
        padding: 4px 12px;
        text-decoration: none;
        color: rgb(27, 26, 26);
        display: inline-block;
        box-shadow: rgb(255, 255, 255) 1px 1px 0px 0px inset;
        text-shadow: none;
        background: -webkit-gradient(linear, 0% 0%, 0% 100%, color-stop(0.05, rgb(241, 241, 241)), to(rgb(230, 230, 230)));
        font-size: 20px;
        border: 1px solid red;
        outline:none;
    }
    button:active, input:active, select:active, button:focus, input:focus, select:focus {
        background: -webkit-gradient(linear, 0% 0%, 0% 100%, color-stop(5%, rgb(221, 221, 221)), to(rgb(250, 250, 250)));
        border: 1px solid rgb(142, 142, 142);
    }
    button[disabled], iput[disabled], select[disabled] {
        background: rgb(249, 249, 249);
        border: 1px solid rgb(218, 207, 207);
        color: rgb(197, 189, 189);
    }
    input, input:focus, input:active {
        background: white;    
    }
</style>
<title>Smart Data Distribution</title>
<h1>Smart Data Distribution</h1>
<hr>
This project allows smart data distribution, server will distribute the data in chunks to its connected peers after configured interval.
<hr>
<hr>
<div id="files-container"></div>
<div>
    <label for="cars">Select data delivery priority (seconds):</label>
    <select name="ddp" id="ddp">
        <option value="5" selected>5</option>
        <option value="10">10</option>
        <option value="15">15</option>
        <option value="20">20</option>
    </select>
    <br>
    <hr>
    <input
    type="text"
    id="broadcast-id"
    placeholder="broadcast-id"
    value="room-xyz"
    >
    <button id="open-or-join">Connect / Start Streaming</button>
    <!-- <button id="start-streaming">Start streaming</button> -->
</div>
<div id="receiver">
    <h3>Received Data:</h3>
    <br>
    <textarea id="recText" rows="50" cols="100" disabled></textarea>
</div>
<script src="/socket.io/socket.io.js"></script>
<script src="/RTCMultiConnection.js"></script>
<script>
var socket = io.connect();
const END_OF_FILE_MESSAGE = 'EOF';
var broadcastid;
// using single socket for RTCMultiConnection signaling
var onMessageCallbacks = {};
socket.on('message', function(data) {
    console.log(data)
    //if (data.sender == connection.userid) return;
    
    if (onMessageCallbacks[data.channel]) {
        onMessageCallbacks[data.channel](data.message);
    };
});

// initializing RTCMultiConnection constructor.
function initRTCMultiConnection(userid) {
    var connection = new RTCMultiConnection();
    connection.body = connection.filesContainer = document.getElementById('files-container');
    connection.channel = connection.sessionid = connection.userid = userid || connection.userid;
    connection.sdpConstraints.mandatory = {
        OfferToReceiveAudio: false,
        OfferToReceiveVideo: false
    };
    // using socket.io for signaling
    connection.openSignalingChannel = function(config) {
        var channel = config.channel || this.channel;
        onMessageCallbacks[channel] = config.onmessage;
        if (config.onopen) setTimeout(config.onopen, 1000);
        return {
            send: function(message) {
                socket.emit('message', {
                    sender: connection.userid,
                    channel: channel,
                    message: message
                });
            },
            channel: channel
        };
    };
    connection.onMediaError = function(error) {
        alert(JSON.stringify(error));
    };
    return connection;
}

// this RTCMultiConnection object is used to connect with existing users
var connection = initRTCMultiConnection();

connection.getExternalIceServers = false;

connection.onmessage = function(data) {
    //console.log(data)       
    messageHandler(data.data)
};

connection.onopen = function(event) {

    if (connection.isInitiator == false && !connection.broadcastingConnection) {
        // "connection.broadcastingConnection" global-level object is used
        // instead of using a closure object, i.e. "privateConnection"
        // because sometimes out of browser-specific bugs, browser 
        // can emit "onaddstream" event even if remote user didn't attach any stream.
        // such bugs happen often in chrome.
        // "connection.broadcastingConnection" prevents multiple initializations.

        // if current user is broadcast viewer
        // he should create a separate RTCMultiConnection object as well.
        // because node.js server can allot him other viewers for
        // remote-stream-broadcasting.
        connection.broadcastingConnection = initRTCMultiConnection(connection.userid);
        connection.broadcastingConnection.onopen = function() {
            // document.querySelector('h1').innerHTML = 'Remote user <b>' + event.userid + '</b> is connected.';

            // share old received files with new users!
            if(connection.broadcastingConnection.isInitiator && connection.lastFile) {
                setTimeout(function() {
                    connection.broadcastingConnection.send(connection.lastFile);
                }, 2000);
            }
        };
        connection.broadcastingConnection.body = connection.broadcastingConnection.filesContainer = document.getElementById('files-container');
        connection.broadcastingConnection.session = connection.session;

        // forwarder should always use this!
        connection.broadcastingConnection.sdpConstraints.mandatory = {
            OfferToReceiveVideo: false,
            OfferToReceiveAudio: false
        };

        connection.broadcastingConnection.open({
            dontTransmit: true
        });
    }
};

// ask node.js server to look for a broadcast
// if broadcast is available, simply join it. i.e. "join-broadcaster" event should be emitted.
// if broadcast is absent, simply create it. i.e. "start-broadcasting" event should be fired.
document.getElementById('open-or-join').onclick = function() {
    broadcastid = document.getElementById('broadcast-id').value;
    if (broadcastid.replace(/^\s+|\s+$/g, '').length <= 0) {
        alert('Please enter broadcast-id');
        document.getElementById('broadcast-id').focus();
        return;
    }

    this.disabled = true;

    connection.session = {
        data: true,
        oneway: true
    };

    let ddp = document.getElementById('ddp').value

    socket.emit('join-broadcast', {
        broadcastid: broadcastid,
        userid: connection.userid,
        typeOfStreams: connection.session,
        deliveryPriority: ddp
    });

};

// document.getElementById('start-streaming').onclick = function() {
//     let ddp = document.getElementById('ddp').value
//     socket.emit('set-delivery-priority', {
//         broadcastid: broadcastid,
//         userid: connection.userid,
//         typeOfStreams: connection.session
//     });
// }

// this event is emitted when a broadcast is already created.
socket.on('join-broadcaster', function(broadcaster, typeOfStreams, first_chunk) {
    connection.session = typeOfStreams;
    connection.channel = connection.sessionid = broadcaster.userid;

    connection.sdpConstraints.mandatory = {
        OfferToReceiveVideo: !!connection.session.video,
        OfferToReceiveAudio: !!connection.session.audio
    };

    connection.join({
        sessionid: broadcaster.userid,
        userid: broadcaster.userid,
        extra: {},
        session: connection.session
    });

    document.getElementById("ddp").disabled = false

    messageHandler(first_chunk)

});

// this event is emitted when a broadcast is absent.
socket.on('start-broadcasting', function(typeOfStreams, first_chunk) {
    // host i.e. sender should always use this!
    connection.sdpConstraints.mandatory = {
        OfferToReceiveVideo: false,
        OfferToReceiveAudio: false
    };
    connection.session = typeOfStreams;
    connection.open({
        dontTransmit: true
    });

    if (connection.broadcastingConnection) {
        // if new person is given the initiation/host/moderation control
        connection.broadcastingConnection.close();
        connection.broadcastingConnection = null;
    }

    document.getElementById("ddp").disabled = false

    messageHandler(first_chunk)
    // let textArray = file_data.split("\n");
    // let len = textArray.length;
 
    // let broadcast_interval = 5000 // milliseconds
    // let i = 0

    });

    socket.on(connection.userid + '-get-stream', function(stream) {

        document.getElementById("ddp").disabled = false

        messageHandler(stream)

    });

    function messageHandler(data) {
        document.getElementById('recText').value += data
    }

</script>
